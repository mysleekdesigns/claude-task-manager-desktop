/**
 * Claude Code Hooks Service
 *
 * Generates hooks configuration for Claude Code to enforce phase boundaries.
 * The Stop hook validates that work was scoped to the specified phase.
 */

import { promises as fs } from 'fs';
import path from 'path';

// ============================================================================
// Types
// ============================================================================

/**
 * Hook configuration for a single hook entry
 */
interface HookEntry {
  type: 'command';
  command: string;
}

/**
 * Hook matcher configuration
 */
interface HookMatcher {
  matcher?: string;
  hooks: HookEntry[];
}

/**
 * Claude Code hooks configuration structure
 */
interface HooksConfig {
  hooks?: {
    Stop?: HookMatcher[];
    PreToolUse?: HookMatcher[];
  };
}

// ============================================================================
// Constants
// ============================================================================

/** Directory name for Claude configuration */
const CLAUDE_DIR = '.claude';

/** Hooks configuration filename */
const HOOKS_FILE = 'hooks.json';

/** Scripts subdirectory */
const SCRIPTS_DIR = 'scripts';

/** Phase validator script filename */
const VALIDATOR_SCRIPT = 'phase-validator.sh';

// ============================================================================
// ClaudeHooksService
// ============================================================================

/**
 * ClaudeHooksService manages Claude Code hooks configuration for phase validation.
 *
 * Features:
 * - Generate hooks config for phase-scoped tasks
 * - Create validator scripts that enforce phase boundaries
 * - Clean up hooks configuration after task completion
 */
class ClaudeHooksService {
  /**
   * Generate hooks config for a phase-scoped task.
   *
   * Creates a .claude/hooks.json file in the project directory with a Stop hook
   * that calls the phase validator script.
   *
   * @param phaseNumber - The phase number the task is scoped to
   * @param phaseName - The phase name for display
   * @param projectPath - Path to write the hooks config
   * @returns Path to the generated hooks.json file
   */
  async generatePhaseHooksConfig(
    phaseNumber: number,
    phaseName: string,
    projectPath: string
  ): Promise<string> {
    // Ensure the .claude directory exists
    const claudeDir = path.join(projectPath, CLAUDE_DIR);
    await fs.mkdir(claudeDir, { recursive: true });

    // Create the validator script first
    const validatorPath = await this.createPhaseValidatorScript(
      phaseNumber,
      projectPath
    );

    // Build the hooks configuration
    const hooksConfig: HooksConfig = {
      hooks: {
        Stop: [
          {
            matcher: '',
            hooks: [
              {
                type: 'command',
                command: `${validatorPath} ${String(phaseNumber)} "${phaseName}"`,
              },
            ],
          },
        ],
      },
    };

    // Write the hooks configuration
    const hooksPath = path.join(claudeDir, HOOKS_FILE);
    await fs.writeFile(hooksPath, JSON.stringify(hooksConfig, null, 2), 'utf-8');

    console.log(
      `[ClaudeHooksService] Generated hooks config at ${hooksPath} for Phase ${String(phaseNumber)}: ${phaseName}`
    );

    return hooksPath;
  }

  /**
   * Create a Stop hook script that validates phase completion.
   *
   * The script:
   * 1. Accepts the phase number as an argument
   * 2. Logs validation information to stderr (for debugging)
   * 3. Outputs the JSON decision to stdout
   * 4. Is made executable
   *
   * @param phaseNumber - Phase to validate
   * @param projectPath - Project path where the script will be created
   * @returns Path to the generated script
   */
  async createPhaseValidatorScript(
    phaseNumber: number,
    projectPath: string
  ): Promise<string> {
    // Ensure the scripts directory exists
    const scriptsDir = path.join(projectPath, CLAUDE_DIR, SCRIPTS_DIR);
    await fs.mkdir(scriptsDir, { recursive: true });

    // Build the validator script
    // This is a simple implementation that logs the phase boundary and always allows
    // Future enhancements could:
    // - Parse Claude Code output to verify only phase-specific work was done
    // - Check git diff to ensure changes are phase-appropriate
    // - Integrate with the PRD parser to validate requirements
    const scriptContent = `#!/bin/bash
# Phase Validator Script for Claude Code Hooks
# Generated by Claude Tasks Desktop
#
# This script is called by Claude Code's Stop hook to validate that
# work was scoped to the specified phase.
#
# Arguments:
#   $1 - Phase number
#   $2 - Phase name (optional)
#
# Output:
#   JSON decision to stdout: {"decision": "allow"} or {"decision": "block", "reason": "..."}

PHASE_NUMBER="\${1:-unknown}"
PHASE_NAME="\${2:-Phase $PHASE_NUMBER}"

# Log validation info to stderr (visible in terminal but not captured as decision)
>&2 echo "[Phase Validator] Validating work for Phase $PHASE_NUMBER: $PHASE_NAME"
>&2 echo "[Phase Validator] Task completion acknowledged"

# For now, always allow completion
# Future enhancement: analyze the work done and verify it matches the phase scope
echo '{"decision": "allow"}'
`;

    // Write the script
    const scriptPath = path.join(scriptsDir, VALIDATOR_SCRIPT);
    await fs.writeFile(scriptPath, scriptContent, 'utf-8');

    // Make the script executable
    await fs.chmod(scriptPath, 0o755);

    console.log(
      `[ClaudeHooksService] Created phase validator script at ${scriptPath} for Phase ${String(phaseNumber)}`
    );

    return scriptPath;
  }

  /**
   * Clean up hooks config after task completion.
   *
   * Removes the hooks.json file and validator script from the project directory.
   * This should be called when the task completes to avoid leaving behind
   * configuration that could affect future Claude Code sessions.
   *
   * @param projectPath - Project path to clean up
   */
  async cleanupHooksConfig(projectPath: string): Promise<void> {
    const claudeDir = path.join(projectPath, CLAUDE_DIR);
    const hooksPath = path.join(claudeDir, HOOKS_FILE);
    const scriptsDir = path.join(claudeDir, SCRIPTS_DIR);
    const validatorPath = path.join(scriptsDir, VALIDATOR_SCRIPT);

    // Remove the validator script
    try {
      await fs.unlink(validatorPath);
      console.log(`[ClaudeHooksService] Removed validator script: ${validatorPath}`);
    } catch (error) {
      // Ignore if file doesn't exist
      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
        console.error(
          `[ClaudeHooksService] Failed to remove validator script:`,
          error
        );
      }
    }

    // Try to remove the scripts directory if empty
    try {
      await fs.rmdir(scriptsDir);
      console.log(`[ClaudeHooksService] Removed scripts directory: ${scriptsDir}`);
    } catch {
      // Ignore - directory might not be empty or might not exist
    }

    // Remove the hooks configuration
    try {
      await fs.unlink(hooksPath);
      console.log(`[ClaudeHooksService] Removed hooks config: ${hooksPath}`);
    } catch (error) {
      // Ignore if file doesn't exist
      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
        console.error(
          `[ClaudeHooksService] Failed to remove hooks config:`,
          error
        );
      }
    }

    console.log(`[ClaudeHooksService] Cleaned up hooks configuration for ${projectPath}`);
  }

  /**
   * Get the path to the hooks config file for a project.
   *
   * @param projectPath - Project path
   * @returns Path to the hooks.json file
   */
  getHooksConfigPath(projectPath: string): string {
    return path.join(projectPath, CLAUDE_DIR, HOOKS_FILE);
  }

  /**
   * Check if hooks config exists for a project.
   *
   * @param projectPath - Project path
   * @returns True if hooks.json exists
   */
  async hasHooksConfig(projectPath: string): Promise<boolean> {
    const hooksPath = this.getHooksConfigPath(projectPath);
    try {
      await fs.access(hooksPath);
      return true;
    } catch {
      return false;
    }
  }
}

// Export singleton instance
export const claudeHooksService = new ClaudeHooksService();
